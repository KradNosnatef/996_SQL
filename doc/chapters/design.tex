\documentclass[../report.tex]{subfiles}
\begin{document}

\section {数据库设计}

\subsection {数据库设计需求}

学校有多个校区,各个校区均有其校区代码(唯一)、校区名称和校区地址
(实体中包括但不限于上述属性,下同)。学校开设多个专业,各个专业均有其
专业代码(唯一)、专业名称、专业地址、专业负责人和所属校区(一个专业仅
属于一个校区)。学校建立多个班级,各个班级均有其班级代码(唯一)、班级
名称、建班年月、班主任、所属年级(年份)和所属专业。

学校将所有教师和学生的基本个人信息统一存放,包括身份证件号(唯一)、
身份证件类型(身份证或护照)、中文名称、性别码(女或男)、出生日期(年
月日)和国籍(中文名称)。如果教师和学生提供了家庭通讯方式,包括家庭住
址、家庭邮政编码和家庭电话,学校也会记录。每个教师也有属于自己的工号(唯
一),每个学生有属于自己的学号(唯一)。学校记录学生的入学年月、电子邮
箱和所属班级,也记录教师的入职年月、电子邮箱、所属专业和职称(教授或副
教授)。学校允许学生转专业和降级(二者不同时发生,转专业和降级时均转班,
且只允许一次转专业和一次降级),统称为学籍异动。学生发生学籍异动时需要
记录异动编号(唯一,同一学生转专业和降级各有不同的异动编号)、异动日期
(年月)、原班级代码和现班级代码。转专业还需要记录是否已转出团员关系(是、
否或不是团员),降级则还需要记录降级原因(休学或支教)。

学校开设不同课程,每门课程均有其课程号(唯一,与课程名称一一对应)、
课程名称、开课专业和考核方式(考试或当堂答辩,满分均为 100)。当一门课
程开课时,需要记录其授课教师(一门课仅有一个授课教师)、开课日期(年)、
开课学期(春或秋)、开课时间(每个课程一周只开一节课,为周一至周五的第
一节至第九节中的某一节,自定义记录方式)。学校会记录每个学生的选课记录
(不允许重复选课),包括选课日期(同开课日期)、选课学期(同开课学期)
和考试成绩。

\subsection {数据库设计与改良}

这里结合第二次实验的设计报告，去给出我们最初选择的数据库设计。

\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{../figure/database-design.png}
\caption{数据库设计一览}
\label{fig:database-design}
\end{figure}

在实际实现的时候，大家迅速发现了问题，单独列出Student\_Identity表，对于我们的信息维护几位不方便。所以最终，在这一版数据库的基础上，我们给Student和Teacher分别增加了一个外健，用于和Person链接。

最终用于生成数据库框架的代码：
\MYhref{https://github.com/KradNosnatef/996_SQL/blob/master/src/main/resources/sql_init.sql}{\underline{database-init-github-link}}

\section{管理系统总体框架的设计}

我们的框架基本按照一般的前后端分离的办法操作。

Login Servlet 是我们应用的大门，用于处理登陆信息。

User-Type 是我们登陆后第一个需要审查的元素。 我们通过他来判断我们的用户的类别。

我们的用户分为3个基本类别：

1. \texttt{Admin Account} 有所有功能的权限

2. \texttt{Student Account} 只有部分查询权限，可以对自己的个人信息修改

3. \texttt{Teacher Account} 只有煮粉查询权限，可以查询所有学生信息，可以对自己的个人信息修改

\begin{figure}[H]
\centering
\includegraphics[width=1.1\linewidth]{figure/framework}
\caption{framework}
\label{fig:untitledpage}
\end{figure}

我们管理权限主要是利用前端强制管理，这里是我们设计的不足之处。在对应的用户页面上之开放他能用的功能。但是，如果用户足够细心和好运，他可以通过观察我们发出的HTTP Request从而对我们的信息进行解析。继而通过Postman等工具，发送请求，就可以轻松获取自己权限以外的操作。

正确的做法是，处理所有HTTP请求是，处理带上session或者token，记录下用户的类型。此外，对于java servlet发送的请求，我们应当适度做一些加密操作。

\section{后端设计}

\subsection{一览}

后端大体框架为4部分：
\begin{itemize}
\itemsep -0.3em
\ttfamily
\item DAO： Data Access Object 主要用来做各种实体的数据库操作 
\item model： 存放各种实体的数据类型
\item service： 存放各种 Java Serrvlet 服务
\item utils： 常用API的单独存放
\end{itemize}

\subsection{utils}

这里我没有按照字典序介绍，而是理解由易到难的次序介绍。

首先是utils里的各个模块：

\begin{enumerate}
\itemsep 0em
\ttfamily 
\item Datautils 处理我们 Data 等特殊格式的数据的格式标准化
\item DButils 处理我们的数据库连接和断开的操作
\item UnitTestSwitch 用于切换本地 JDBC 数据库和 Tomcat 的 JDBI 数据库连接方式，这一模块只存放一个常量，可以理解成 Java 下的条件编译，目的是为了方便的单元测试
\end{enumerate}

\subsection{model}

对各个基本实体做存储，为各个实体做了一层封装。

\begin{enumerate}
\itemsep 0em
\ttfamily 
\item Campus 存储校区信息
\item Class 存储班级信息
\item Course 存储课程信息
\item Department 存储专业信息
\item Person 存储个人基本信息
\item Student 存储学生特有信息
\item Teacher 存储教师特有信息
\item Transaction 存储异动信息
\item Users 存储用户信息，用于系统登陆
\end{enumerate}

类型细节见程序注释。

\subsection{DAO}

这一部分为程序的核心，用于处理我们的数据库操作。我们的数据库和Java程序全是依靠他们进行连接。

我们这里不论我们的DAO母体，我们有一些公共的设计规则：
\begin{enumerate}
\ttfamily
\item 插入方法的规则\\
名称：\\
insert[Model\_Name]\\
输入：\\
对于所有的插入方法，参数为我们建立Dao对应母体的Class Model的所有需要的参数。\\
输出：\\
如果插入成功，返回非0数值，为SQL DML(Data Manipulation Language)的行号。\\
如果插入失败，返回0。如果插入成功，返回非0数值，为SQL DML(Data Manipulation Language)的行号。\\
如果插入失败，返回0。
\item 删除方法的规则\\
名称：\\
delete[Model\_Name]\\
输出：\\
对于所有的删除方法，参数为(String element\_selector, int type)\\
element\_selector 为我们的选择子，用于选定我们待删除的对象。\\
type 用于选择我们的选择子的含义。\\
我们只提供了“合理”的删除方法。这里的合理定义是符合一般常理的，例如根据院长去删除一个专业，这种事情听起来即不合理，且极容易发生操作失误。这类借口我们一律不予提供。\\
输出：\\
如果返回值为0, 待删除元素不存在。\\
如果返回值为1, 删除成功。\\
如果返回值为-1, 数据库操作异常。
\item 查询方法的规则
名称：\\
query[Model\_Name]\\
输入：\\
对于所有的查询方法，参数为(String element\_selector, int type)\\
element\_selector 为我们的选择子，用于选定我们待查询的对象。\\
type 用于选择我们的选择子的含义。\\
type = -1 表示查询所有元素的所有信息。\\
输出：\\
一个ArrayList<Model>，Model为DAO对应母体的类型。
\item 更新方法的规则
名称：\\
update[Model\_Name]\\
对于所有的更新方法，我们有两种类型：
\begin{itemize}
\item 
Update Detail Mode\\
输入：\\
参数为(int old\_type, int new\_type, String old\_value, String new\_value)\\
old\_XXX用于确定我们的更改目标，old\_type用于说明old\_value的含义。old\_value则是我们的目标的选择子。\\
new\_type指定说明我们的目标更改项，目标项的new\_type代表的属性，需要更新为new\_value。\\
输出：
\item 
Rebuild Update Mode\\
输入：\\
这里需要输入了一个基本的用于定位元素的键值，一般是主键，当然，特定情况也有其他的选择方案。
\end{itemize}

\end{enumerate}

\subsubsection{CampusDao}
用于对校区进行数据库操作。
\begin{enumerate}
\ttfamily 
\item 插入校区\\
public int insertCampus(String id, String name, String address)
\begin{itemize}
\item id： 待插入校区id
\item name: 待插入校区名称
\item address: 待插入校区地址
\end{itemize}


\item 删除校区\\
public int deleteCampus(String element\_selector, int type)
\begin{itemize}
\item element\_selector: 待删除校区选择子
\item type: 选择子类型
\end{itemize}
这里我们根据我们的选择子选定待删除的校区。\\
有如下规定：
\begin{itemize}
\item type = 0， 根据id选择校区并删除。
\item type = 1， 根据校区名选择校区并删除。
\item 其他type值非法。
\end{itemize}

\item 查询校区\\
public ArrayList<Campus> queryCampus(String element\_selector, int type)
\begin{itemize}
\item element\_selector: 查询所用选择子
\item type: 选择子类型
\end{itemize}
这里我们的选择子有以下规定：
\begin{itemize}
\item type = 0， 根据id查询
\item type = 1， 根据校区名查询
\item type = 2， 根据地址查询
\item type = -1， 查询所有信息
\end{itemize}
返回为一个ArrayList类型变量。

\item 更新校区\\
public int updateCampus(int old\_type, int new\_type, String old\_value, String new\_value)

\end{enumerate}

\subsubsection{ClassDao}
用于对班级进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}
\subsubsection{CourseDao}
用于对课程进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}
\subsubsection{DepartmentDao}
用于对专业进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}
\subsubsection{PersonDao}
用于对个人进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}
\subsubsection{QueryToolKitsDao}
用于对复杂查询进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}
\subsubsection{SelectionDao}
用于对选课进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}
\subsubsection{StudentDao}
用于对学生进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}
\subsubsection{TeacherDao}
用于对教师进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}
\subsubsection{TransactionDao}
用于对异动进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}
\subsubsection{UserDao}
用于对用户进行数据库操作。
\begin{enumerate}
\itemsep 0em
\item 
\end{enumerate}

\end{document}